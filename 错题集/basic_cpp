
basic_cpp

=============


---------------

int i=0; do i++; while(i*i<10);

i=1~4都被do了，一共循环四次；
i=0；
do i++;
注意在“do i++;” 这里，因为分号就是一个顺序点，所以副作用i++已经发生，意味着在第一次进入循环时i的值已经由初值0变成了1.






----------------


#include <iostream>

using namespace std;


int func(int *c)
{
	cout<<*c<<endl;
	return *c;
}

int main()
{
	int (*a)(int *) =func,*b(),w[10],c=100;
	a=a(w);
	(*a)(&c);
	b=*b(w);
	func(b);
	return 0;
}

关于对函数正确调用的例子


---------------

若 a 为 int 类型,且其值为3,则执行完表达式 a+=a-=a*a 后,a 的值是（）。

运算符的优先级、运算符的结合律

a -= a*a     => a = a-a*a = 3-3*3 = -6
a += a        => a = a+a = -6+(-6) = -12




---------------

在 c++ 语言中，对函数参数默认值描述正确的是（）

正确答案: D   你的答案: B (错误)
函数参数的默认值只能设定一个
一个函数的参数若有多个，则参数默认值的设定可以不连续
函数参数必须设定默认值
在设定了参数的默认值后，该参数后面定义的所有参数都必须设定默认值

在设定了默认参数后，为了防止参数匹配发生歧义，后边的参数也要设置成默认的
默认参数一定要从右到左安排


---------------

下面有关空指针和未初始化指针，说法错误的是？
正确答案: D   你的答案: A (错误)
对0x0这个地址取值是非法的
空指针可以确保不指向任何对象或函数; 而未初始化指针则可能指向任何地方。
空指针与任何对象或函数的指针值都不相等
malloc在其内存分配失败时返回的是一个未初始化的指针


malloc函数为C语言中的标准函数，标准中规定：在分配内存失败时会返回“NULL Pointer”空指针，而非为初始化的指针。
C++在分配内存失败时会抛出BAD_ALLOC异常。
野指针：指向垃圾内存的指针，而非空指针。
野指针产生原因：
    1.声明的指针未被初始化，指针默认值随机产生。创建指针应该将其初始化为NULL或者指向某一内存。
    2.free和delete掉的指针未重置为NULL，free后的指针仍指向该内存，但该内存已变为垃圾内存。
另：空指针不指向任何实际的对象或函数，反过来说对象或函数的指针也不可能为空指针。

空指针与野指针的区别，空指针也就是通常指向为NULL的指针，野指针就是指向一块未知的内存区域(可以是通过malloc或new申请空间后，释放后没有将指针置为空)，
也有可能定义了一个指针没有初始化，由于内存空间中的值在未赋值之前是随机数，所以也有可能诞生野指针。
就上面这道题目而言：
A肯定是对的，无法为内存为0的地址取地址
B也是对的咯
C空指针的值肯定是NULL，也就是0，而其他指针都有对象了，有对象就有地址，有地址也就有值了，所以两个值是不可能相等的
Dmalloc申请内存空间失败的时候，人家返回的值为NULL，而不是任意的。


-----------------


用友元函数重载的运算符是（）。
正确答案: A   你的答案: A (正确)
+
=
[]
->

C++规定=，[ ]，()，->这四个运算符只能被重载为类的非静态成员函数，其他的可以被友元重载，
主要是因为其他的运算符重载函数都会根据参数类型或数目进行精确匹配，
这四个不具有这种检查的功能，用友元定义就会出错。


---------------

如下C++程序
1
2
3
int i=0x22222222； 
char szTest[]=”aaaa”;  //a的ascii码为0x61 
func(I, szTest);    //函数原型为void func(int a,char *sz); 
请问刚进入func函数时，参数在栈中的形式可能为 （左侧为地址，右侧为数据—）
正确答案: D   你的答案: 空 (错误)
0x0013FCF0	0x61616161				
0x0013FCF4	0x22222222				  
0x0013FCF8	0x00000000

0x0013FCF0	0x22222222
0x0013FCF4	0x0013FCF8
0x0013FCF8	0x61616161

0x0013FCF0	0x22222222				
0x0013FCF4	0x61616161				
0x0013FCF8	0x00000000

0x0013FCF0	0x0013FCF8
0x0013FCF4	0x22222222
0x0013FCF8	0x61616161

1，对于x86，栈的增长方向是从大地址到小地址
2，对于函数调用，参数的入栈顺序是从右向左
3，函数调用入栈顺序是  右边参数-->左边参数-->函数返回地址

